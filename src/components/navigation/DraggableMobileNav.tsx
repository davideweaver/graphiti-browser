import { useEffect, useRef, useState } from "react";
import { X } from "lucide-react";
import { PrimaryNav } from "./PrimaryNav";
import { SecondaryNav } from "./SecondaryNav";
import type { PrimaryNavItem } from "@/lib/navigationConfig";

interface DraggableMobileNavProps {
  isOpen: boolean;
  onClose: () => void;
  activePrimary: string | null;
  pathname: string;
  navigationConfig: PrimaryNavItem[];
  onNavigate: (path: string) => void;
  footer?: React.ReactNode;
  secondaryNav?: React.ReactNode;
}

export function DraggableMobileNav({
  isOpen,
  onClose,
  activePrimary,
  pathname,
  navigationConfig,
  onNavigate,
  footer,
  secondaryNav,
}: DraggableMobileNavProps) {
  const [translateX, setTranslateX] = useState(-100);
  const [isDragging, setIsDragging] = useState(false);
  const touchStartX = useRef(0);
  const touchStartY = useRef(0);
  const currentTranslateX = useRef(-100);
  const hasCheckedDirection = useRef(false);

  // Animate open/close when isOpen changes
  useEffect(() => {
    if (isOpen) {
      setTranslateX(0);
      currentTranslateX.current = 0;
      // Prevent body scroll when nav is open
      document.body.style.overflow = "hidden";
    } else {
      setTranslateX(-100);
      currentTranslateX.current = -100;
      // Restore body scroll when nav is closed
      document.body.style.overflow = "";
    }

    // Cleanup on unmount
    return () => {
      document.body.style.overflow = "";
    };
  }, [isOpen]);

  const handleTouchStart = (e: React.TouchEvent) => {
    touchStartX.current = e.touches[0].clientX;
    touchStartY.current = e.touches[0].clientY;
    hasCheckedDirection.current = false;
    // Don't set isDragging yet - wait to see direction
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    const currentX = e.touches[0].clientX;
    const currentY = e.touches[0].clientY;
    const deltaX = currentX - touchStartX.current;
    const deltaY = currentY - touchStartY.current;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);

    // Check direction on first significant movement (10px threshold)
    if (!hasCheckedDirection.current && (absDeltaX > 10 || absDeltaY > 10)) {
      hasCheckedDirection.current = true;

      // If more vertical than horizontal, this is a scroll - don't drag
      if (absDeltaY > absDeltaX) {
        setIsDragging(false);
        return;
      }

      // If more horizontal, this is a drag
      setIsDragging(true);
    }

    // Only process drag if we've determined it's horizontal
    if (!isDragging || !hasCheckedDirection.current) return;

    const width = window.innerWidth;

    // Convert pixels to percentage
    const deltaPercent = (deltaX / width) * 100;

    // Calculate new position (clamp between -100 and 0)
    let newTranslateX = currentTranslateX.current + deltaPercent;

    // When opening from closed: allow drag from -100 to 0
    // When closing from open: allow drag from 0 to -100
    newTranslateX = Math.max(-100, Math.min(0, newTranslateX));

    setTranslateX(newTranslateX);

    // Prevent scrolling during horizontal drag
    e.preventDefault();
  };

  const handleTouchEnd = () => {
    if (!isDragging) {
      // Reset if we never actually started dragging
      hasCheckedDirection.current = false;
      return;
    }

    setIsDragging(false);
    hasCheckedDirection.current = false;

    // Snap to open or closed based on position
    if (translateX > -50) {
      // Closer to open
      setTranslateX(0);
      currentTranslateX.current = 0;
      if (!isOpen) {
        // Trigger parent state update (but don't actually need it since we control position)
      }
    } else {
      // Closer to closed
      setTranslateX(-100);
      currentTranslateX.current = -100;
      if (isOpen) {
        onClose();
      }
    }
  };

  // Primary nav: navigate but keep sidebar open
  const handlePrimaryNavigate = (path: string) => {
    onNavigate(path);
  };

  // Secondary nav: navigate and close sidebar
  const handleSecondaryNavigate = (path: string) => {
    onNavigate(path);
    onClose();
  };

  if (!isOpen && translateX === -100) return null;

  return (
    <>
      {/* Overlay */}
      <div
        className="fixed inset-0 z-50 bg-black/80 md:hidden"
        style={{
          opacity: (translateX + 100) / 100,
          pointerEvents: translateX === -100 ? "none" : "auto",
          transition: isDragging ? "none" : "opacity 300ms ease-in-out",
        }}
        onClick={onClose}
      />

      {/* Drawer */}
      <div
        className="fixed inset-y-0 left-0 z-50 w-full bg-background shadow-lg md:hidden overflow-hidden"
        style={{
          transform: `translateX(${translateX}%)`,
          transition: isDragging ? "none" : "transform 300ms ease-in-out",
          paddingTop: "env(safe-area-inset-top)",
          paddingBottom: "env(safe-area-inset-bottom)",
          touchAction: isDragging ? "none" : "auto", // Disable all touch actions during drag
        }}
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
      >
        {/* Close button */}
        <button
          onClick={onClose}
          className="absolute left-4 z-10 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100"
          style={{
            top: "calc(1rem + 6px + env(safe-area-inset-top))",
          }}
        >
          <X className="h-8 w-8" />
          <span className="sr-only">Close</span>
        </button>

        {/* Content - flex container with no scroll */}
        <div className="flex h-full">
          <PrimaryNav
            navigationConfig={navigationConfig}
            activePrimary={activePrimary}
            onNavigate={handlePrimaryNavigate}
            footer={footer}
          />
          {secondaryNav || (
            <SecondaryNav
              activePrimary={activePrimary}
              pathname={pathname}
              onNavigate={handleSecondaryNavigate}
            />
          )}
        </div>
      </div>
    </>
  );
}
